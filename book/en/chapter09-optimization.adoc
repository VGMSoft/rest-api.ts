[#chapter09-optimization]
= Optimizations

In the previous chapter, we managed to set up the basics for the configuration of our application. This chapter will perfect this base and add the _Model_ layer, which will store the data and add the first tests.

In the next chapters, we will deal with user authentication using authentication tokens and defining permissions to limit access to connected users. We will then link products to users and give them the ability to place orders.

As you can already imagine, there are many authentication solutions for Node.js, such as http://www.passportjs.org/[Passport.js], https://github.com/ianstormtaylor/permit[Permit], and https://github.com/simov/grant[Currency]. These solutions are turnkey libraries, meaning that they allow you to manage many things like authentication, password forgetting functionality, validation, etc.

We won't use them to better understand the authentication mechanism. This will allow you to discover nothing magic behind password encryption and the creation of authentication tokens.

This chapter will be complete. It may be long, but I will try to cover as many topics as possible. Feel free to grab a coffee, and let's go. By the end of this chapter, you will have built all the user logic, validation, and error handling.

== Setting up TypeORM

Here we will put the _Model_ layer of the _design patern_ MVC. This is the layer related to the database.

To access the database, we will use an ORM (Object Relational Mapper). The purpose of an ORM is to interact with the database and save you from writing SQL queries by hand. It also allows us to add an abstraction layer to the database type and not worry about the differences between PostgreSQL and SQLite, for example.

There are several ORMs for Nodejs: https://sequelize.org/[Sequelize], https://mongoosejs.com/[Mongoose] and https://typeorm.io/[TypeORM]. I chose the last one because it is the one that integrates best with Typescript. It also offers a https://typeorm.io/#/active-record-data-mapper [Active Record AND Data Mapper] approach that I like very much.

To install it is straightforward. We are going to install the TypeORM library but also two additional libraries :

* `sqlite3` which will allow us to dialogue with our Sqlite database.
* https://www.npmjs.com/package/dotenv[`dotenv`] will allow us to start defining *environment variables* such as the connection to our database.

Here we go:

.Adding libraries to install TypeORM
[source,bash]
----
npm add typeorm sqlite3 dotenv --save
----

We will now generate our configuration file. By default, `dotenv` will look for a file named `.env`. Let's create it:

[source,bash]
----
touch .env
----

And let's start by defining https://github.com/typeorm/typeorm/blob/master/docs/using-ormconfig.md#using-environment-variables [TypeORM environment variables] for a basic connection to an SQLite database:

The basic configuration of TypeORM for a connection to SQLite
[source,env]
----
TYPEORM_CONNECTION=sqlite
TYPEORM_DATABASE=db/development.sqlite
TYPEORM_LOGGING=true
TYPEORM_SYNCHRONIZE=true
TYPEORM_ENTITIES=src/entities/*.entity.ts,dist/entities/*.entity.js
----

As you can see, we define that we will use SQLite and that the database will be stored in the `db/` folder. `TYPEORM_SYNCHRONIZE` allows us to avoid not worrying about migrations and so let TypeORM do the modifications on our database schema if necessary. We then specify where our entities are located with `TYPEORM_ENTITIES`.

All we have to do is configure `dotenv` to load this file. To do this, I use Node.js' _flag_ `--require`, which allows us to pre-load a library. You just have to modify the `package.json`:

.the basic TypeORM configuration for a connection to SQLite
[source,json]
----
{
  // ...
  "scripts": {
    "start": "tsc && node dist/main.js -r dotenv/config",
    "start:watch": "nodemon",
    // ...
  },
  // ...
}
----

We will now create a `DatabaseService` that will take care of connecting TypeORM to our database. As we have implemented addiction injection, this service will also be injectable. Here is the complete implementation. Don't panic. I'll detail the logic next.

[source,ts]
----
// src/services/database.service.ts
import {inject, injectable} from 'inversify';
import {Connection, createConnection, ObjectType} from 'typeorm';
import {TYPES} from '../core/types.core';
import {Logger} from './logger.service';

@injectable()
export class DatabaseService {
  private static connection: Connection;

  public constructor(@inject(TYPES.Logger) private readonly logger: Logger) {}

  public async getConnection(): Promise<Connection> {
    if (DatabaseService.connection instanceof Connection) {
      return DatabaseService.connection;
    }

    try {
      DatabaseService.connection = await createConnection();
      this.logger.log('INFO', `Connection established`);
    } catch (e) {
      this.logger.log('ERROR', 'Cannot establish database connection', e);
      process.exit(1);
    }

    return DatabaseService.connection;
  }

  public async getRepository<T>(repository: ObjectType<T>): Promise<T> {
    const connection = await this.getConnection();
    return await connection.getCustomRepository<T>(repository);
  }
}
----

This class has two methods:

- `getConnection` : this method will initialize a new connection to the database. This one will call the `createConnection` method, which will look for https://typeorm.io/#/using-ormconfig[an ormconfig file] (in our case, the environment variables loaded by `dotenv`) and establish a connection. Once the connection is made, it is stored in a static property, which will be returned the next time directly.
- `getRepository`: this method will allow us to manipulate our models via the repository. We will talk about it in details later

NOTE: It is good practice to hide the logic of the library from our own class. This will allow us to depend on the library and to be able to migrate more easily if one day, we want to change.

Now that our service is created, we need to add it to our container :

Add the `Symbol` linked to the `DatabaseService` service.
[source,ts]
----
// src/core/types.core.ts
export const TYPES = {
  // ...
  DatabaseService: Symbol.for('DatabaseService'),
};
----

.Registration of the `DatabaseService` service in the Inversify container.
[source,ts]
----
// src/core/container.core.ts
import {Container} from 'inversify';
import {DatabaseService} from '../services/database.service';
// ...
export const container = new Container();
// ...
container.bind(TYPES.DatabaseService).to(DatabaseService);
----

And there you go.

We can now create our first `User` model. Using the _patern Data Mapper_, we will have to create two classes :

- the _entity_ : it will define the fields' attributes to be saved in the database. In our case, I will simply create two attributes: `email` and `password` (the password will be encrypted later).
- the _repository_: it will add some logic to save our entities.

To simplify the example, I will put these two classes in the same file, but you can separate them very well :

[source,ts]
----
// src/entities/user.entity.ts
import {
  Column,
  Entity,
  EntityRepository,
  PrimaryGeneratedColumn,
  Repository,
} from 'typeorm';

@Entity()
export class User {
  @PrimaryGeneratedColumn()
  id: number;

  @Column({unique: true})
  email: string;

  @Column()
  password: string;
}

@EntityRepository(User)
export class UserRepository extends Repository<User> {}
----

And there you go. The result is really very simple, thanks to the `@columns` decorators offered by TypeORM. They can also define the type of information stored (text, date, etc...). The implementation of this model is sufficient for the moment.

Our work is not very visible but hold on because you will see the result in the next section.

We can commit the changes made so far:

[source,bash]
----
git add .
$ git commit -m "Setup TypeORM"
----

== Creating the user controller

Now it's time to get to the concrete part and create the controller to manage the users. This controller will respect the REST standards and propose classic CRUD actions. I.e. _**C**reate_, _**R**ead_, _**U**pdate_ and _**D**elete_.

=== List users

We will start with the `index' method, which is the simplest.

As we saw earlier, controllers can inject our services. So we will inject the `DatabaseService` to be able to retrieve the `UserRepository`. Then we will just have to call the `userRepository.find` method to get the list of all users (which is empty for the moment).

Here is the implementation of our controller:


.Création du `UserController` avec la méthode `index`
[source,ts]
----
// src/controllers/users.controller.ts
import {Request, Response} from 'express';
import {inject} from 'inversify';
import {controller, httpGet} from 'inversify-express-utils';
import {TYPES} from '../core/types.core';
import {UserRepository} from '../entities/user.entity';
import {DatabaseService} from '../services/database.service';

@controller('/users')
export class UsersController {
  public constructor(@inject(TYPES.DatabaseService) private readonly database: DatabaseService) {}

  @httpGet('/')
  public async index(req: Request, res: Response) {
    const userRepository = await this.database.getRepository(UserRepository);

    const users = await userRepository.find();
    return res.json(users);
  }
}
----

