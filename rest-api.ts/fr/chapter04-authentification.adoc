[#chapter04-authentification]
= Authentification des utilisateurs

Dans ce chapitre, les choses vont devenir plus intéressantes. Nous allons mettre en place notre mécanisme d’authentification. À mon avis, ce sera l’un des chapitres les plus intéressants car nous allons introduire beaucoup de nouveaux concepts. A la fin, vous aurez un système d’authentification simple mais puissante. Ne paniquez pas, nous y arriverons.

== Sessions sans état

Avant d’aller plus loin, quelque chose doit être clair: une API ne gère pas les sessions. Cela peut paraître un peu fou si vous n’avez pas d’expérience dans la création de ce genre d’applications. Une API doit être sans état. Ce qui signifie, par définition, qu’une API qui fournit une réponse après votre demande ne nécessite aucune autre attention. Cela a pour conséquence qu’aucun état antérieur ou futur n’est nécessaire pour que le système fonctionne.

Le processus d’authentification de l’utilisateur via une API est très simple:

. Le client demande une ressource de sessions avec les informations d’identification correspondantes (généralement un e-mail et un mot de passe).
. Le serveur renvoie la ressource utilisateur avec son jeton d’authentification correspondant.
. Pour chaque page qui nécessite une authentification, le client doit envoyer ce jeton d’authentification.

Dans cette section et la suivante, nous nous concentrerons sur la construction d’un contrôleur de sessions avec ses actions correspondantes. Nous compléterons ensuite le flux de demandes en ajoutant l’accès d’autorisation nécessaire.

== Présentation de JSON Web Token

Lorsqu’on parle de jeton d’authentification, un standard existe: le JSON Web Token (JWT).

____
JWT est un standard ouvert défini dans la RFC 75191. Il permet l’échange sécurisé de jetons (tokens) entre plusieurs parties. – https://fr.wikipedia.org/wiki/JSON_Web_Token[Wikipédia]
____

Globalement, un jeton JWT est composé de trois parties :

* un en-tête structuré en JSON qui contiendra par exemple la date de validité du jeton.
* un payload structuré en JSON qui peut contenir n’importe quelle donnée. Dans notre cas, il contiendra l’identifiant de l’utilisateur "connecté".
* une signature qui nous permettra de vérifier que le jeton a bien été chiffré par notre application et donc qu’il est valide.

Ces trois parties sont chacune encodées en base64 puis concaténées en utilisant des points (.). Ce qui nous donne quelque chose comme ça:

....
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
....

Une fois décodé, ce jeton nous donne les informations suivantes:

* l'en tête

[source,json]
----
{ "alg": "HS256", "typ": "JWT" }
----

* le payload

[source,json]
----
{ "sub": "1234567890", "name": "John Doe", "iat": 1516239022 }
----

Pour plus d’information à propos des jetons JWT je vous invite à consulter _jxt.io_.

Cela possède beaucoup d’avantages comme par exemple le fait d’envoyer des informations au consommateur de l’API directement dans le token. On pourra par exemple choisir d’intégrer les informations de l’utilisateur dans le payload.

== Mise en place du jeton d’authentification

La norme JWT possède beaucoup d’implémentation dans des langages et des librairies diverses. Bien entendu, il existe une librairie Nodejs à ce sujet: https://github.com/auth0/node-jsonwebtoken[node-jsonwebtoken].

Commençons donc par l’installer:

[source,bash]
----
$ npm install jsonwebtoken
$ npm install --save-dev @types/jsonwebtoken
----

La libraire s'utilise très facilement avec la méthode `jwt.sign` et `jwt.verify`. Voici un exemple :

[source,ts]
----
import { sign, verify } from "jsonwebtoken";

const JWT_PRIVATE_KEY = "123456789";
const payload = { userId: 1 };
const token = sign(payload, JWT_PRIVATE_KEY, { expiresIn: "1 day" });

console.log(verify(token, JWT_PRIVATE_KEY));
// => { userId: 1, iat: 1605730716, exp: 1605817116 }
----

Lors de la première ligne nous avons encodé un `payload` avec la clé secrète `JWT_PRIVATE_KEY`. Nous obtenons donc un jeton que nous pouvons décoder, tout simplement. La deuxième ligne s'occupe de décoder le jeton et nous voyons que nous retrouvons bien notre `payload`.

Nous allons maintenant englober toute cette logique dans une classe `JsonWebTokenService`. Cela nous permettra d'éviter de dupliquer le code. Cette classe s'occupera juste d'encoder et de décoder les jetons JWT. Voici donc l'implémentation :

[source,ts]
----
// src/services/jsonWebToken.service.ts
import { injectable } from "inversify";
import { sign, verify } from "jsonwebtoken";

@injectable()
export class JsonWebTokenService {
  private readonly JWT_PRIVATE_KEY = "123456789";

  encode(payload: Object): string {
    return sign(payload, this.JWT_PRIVATE_KEY, { expiresIn: "1 day" });
  }

  decode(token: string): Object {
    return verify(token, this.JWT_PRIVATE_KEY);
  }
}
----

L'implémentation est très simple. Une méthode encode un payload, l'autre le décode. Comme ce service est injecatble, nous devont l'enregistrer dans le container.

[source,diff]
----
// backend/src/core/types.core.ts
export const TYPES = {
  Logger: Symbol.for("Logger"),
  DatabaseService: Symbol.for("DatabaseService"),
+   JsonWebTokenService: Symbol.for("JsonWebTokenService"),
  // Middlewares
  FetchUserMiddleware: Symbol.for("FetchUserMiddleware"),
};
----

[source,diff]
----
// backend/src/core/container.core.ts
// ...
+ import { JsonWebTokenService } from "../services/jsonWebToken.service";

export const container = new Container();
// services
container.bind(TYPES.Logger).to(Logger);
container.bind(TYPES.DatabaseService).to(DatabaseService);
+ container.bind(TYPES.JsonWebTokenService).to(JsonWebTokenService);
// middlewares
container.bind(TYPES.FetchUserMiddleware).to(FetchUserMiddleware);
----

Et voilà. Nous pouvons même ajouter un petit test rapide qui va encoder et décoder un _payload_ et vérifier que nous retrouvons bien le contenu:

[source,ts]
----
// src/services/jsonWebToken.service.spec.ts
import assert from "assert";
import { container } from "../core/container.core";
import { TYPES } from "../core/types.core";
import { JsonWebTokenService } from "./jsonWebToken.service";

describe("JsonWebTokenService", () => {
  let jsonWebTokenService: JsonWebTokenService;

  before(() => {
    jsonWebTokenService = container.get(TYPES.JsonWebTokenService);
  });

  it("should encode and decode payload", () => {
    const token = jsonWebTokenService.encode({ userId: 1 });
    const payload = jsonWebTokenService.decode(token);
    assert.strictEqual(payload.userId, 1);
  });
});
----

Ce test est un peu plus long que les autres car nous devons récupérer une instance de `=JsonWebTokenService` via la `container`. Pour ce faire, nous utiliser la méthode `before` qui va être exécutée avant notre batterie de test.

Voyons maintenant si tous nos tests passent :

[source,bash]
----
npm test

> backend@1.0.0 test /home/alexandre/github/madeindjs/node_market_place/backend
> ts-mocha src/**/*.spec.ts



  User
    V should hash password

  JsonWebTokenService
    V should encode and decode payload

  isPasswordMatch
    V should match
    V should not match


  4 passing (11ms)
----

C'est parfait. Commitons et passons à la suite :

[source,bash]
----
$ git add . && git commit -m "Create JsonWebTokenService"
----

== Le contrôleur de jetons

=== Mise en place du tests fonctionnel

=== Implémentation

Nous avons donc mis en place le système de génération d'un jeton JWT. Il est maintenant temps de créer une route qui va générer ce jeton. Les actions que nous allons implémenter seront gérées en tant que services _RESTful_: la connexion sera gérée par une demande POST à l’action `create`.

Nous allons donc créer le contrôleur `TokenControler` :

[source,ts]
----
// backend/src/controllers/tokens.controller.ts
import { Request, Response } from "express";
import { inject } from "inversify";
import { controller, httpPost, requestBody } from "inversify-express-utils";
import { TYPES } from "../core/types.core";
import { UserRepository } from "../entities/user.entity";
import { DatabaseService } from "../services/database.service";
import { JsonWebTokenService } from "../services/jsonWebToken.service";
import { isPasswordMatch } from "../utils/password.utils";

@controller("/tokens")
export class TokensController {
  public constructor(
    @inject(TYPES.JsonWebTokenService)
    private readonly jsonWebTokenService: JsonWebTokenService,
    @inject(TYPES.DatabaseService)
    private readonly databaseService: DatabaseService
  ) {}

  @httpPost("")
  public async create(
    @requestBody() body: { email: string; password: string },
    req: Request,
    res: Response
  ) {
    const repository = await this.databaseService.getRepository(UserRepository);
    const user = await repository.findOne({ email: body.email });

    if (!user) {
      return res.sendStatus(400);
    }

    if (isPasswordMatch(user.hashedPassword, body.password)) {
      const token = this.jsonWebTokenService.encode({
        userId: user.id,
        email: user.email,
      });
      return res.json({ token });
    }

    return res.sendStatus(400);
  }
}
----

Oula! Ce ce code à l'air compliqué mais il est en fait très simple :

. on récupère nos services `DatabaseService` et `JsonWebTokenService` dans le constructeur
. on crée une méthode `create` dans le contrôleur qui va s'occuper de créer un token pour l'utilisateur demandé
. cette méthode utilise le `userRepository` pour récupérer l'utilisateur à partir de l'email donné. Si nous ne trouvons pas l'utilisateur, nous renvoyons un code `400` sans donner plus d'explications. En effet, nous ne voulons pas indiquer à l'utilisateur que cet email n'est pas présent en base
. nos utilisont la méthode `isPasswordMatch` pour vérifier si le mot de passe correspond au hash que nous avons stoqué. Si c'est le cas, nous créons et renvoyont un jeton avec la méthode `jsonWebTokenService.encode`

Toulours là ? Tenez bon, il ne bous reste plus qu'à ajouter le contrôleur dans le container :

[source,diff]
----
// backend/src/core/container.core.ts
// ...
+ import "../controllers/tokens.controller";
// ...
----

Essayons la logique dans le terminal. Créons un utilisateur (si ce n'est pas déja fait) :

[source,bash]
----
$ curl -X POST -d "email=test@test.fr" -d "password=test" http://localhost:3000/users
{"email":"test@test.fr","hashedPassword":"8574a23599216d7752ef4a2f62d02b9efb24524a33d840f10ce6ceacda69777b","id":1}
----

Ensuite demandons le jeton pour celui-ci :

[source,bash]
----
$ curl -X POST -d "email=test@test.fr" -d "password=test" http://localhost:3000/tokens
{"token":"eyJhbGciOiJIUzI1NiI..."}
----

Oura! Essayons avec un mot de passe erroné :

[source,bash]
----
$ curl -X POST -d "email=test@test.fr" -d "password=azerty" http://localhost:3000/tokens
Bad Request
----

C'est parfait !

Comittons et passons à la suite :

[source,bash]
----
$ git add . && git commit -m "Create token controller"
----

== Utilisateur connecté

Nous avons donc mis en place la logique suivante: l’API retourne un jeton d’authentification si les paramètres passés d'authentification sont corrects.

Nous allons maintenant implémenter la logique suivante: A chaque fois que ce client demandera une page protégée, nous devrons retrouver l’utilisateur à partir de ce jeton d’authentification que l’utilisateur aura passé dans l’en-tête HTTP.

Dans notre cas, nous utiliserons l’en-tête HTTP `Authorization` qui est souvent utilisé pour ça. Personnellement, je trouve que c’est la meilleure manière parce que cela donne un contexte à la requête sans polluer l’URL avec des paramètres supplémentaires.

Nous allons donc créer un _Middleware_ `FetchLoggerUserMiddleware` pour répondre à nos besoins. C’est-à-dire retrouver l’utilisateur grâce à son jeton d’authentification qui est envoyé sur chaque requête.

=== Mise en place du test fonctionnel

// TODO

=== Implémentation

Le principe est assez identique au précédent _middleware_ que nous avons crée plus tôt donc je passe directement à l'implémentation :

[source,ts]
----
// backend/src/middlewares/fetchLoggedUser.middleware.ts
// ...

@injectable()
export class FetchLoggedUserMiddleware extends BaseMiddleware {
  constructor(
    @inject(TYPES.DatabaseService)
    private readonly databaseService: DatabaseService,
    @inject(TYPES.JsonWebTokenService)
    private readonly jsonWebTokenService: JsonWebTokenService
  ) {
    super();
  }

  public async handler(
    req: Request & { user: User },
    res: Response,
    next: NextFunction
  ): Promise<void | Response> {
    const repository = await this.databaseService.getRepository(UserRepository);
    const token = req.headers.authorization?.replace("bearer", "");

    if (token === undefined) {
      return res.status(403).send("You must provide an `Authorization` header");
    }

    try {
      const payload = this.jsonWebTokenService.decode(token);
      req.user = await repository.findOneOrFail(payload.userId);
    } catch (e) {
      return res.status(403).send("Invalid token");
    }

    next();
  }
}
----

Encore une fois le code paraît long mais il est en fait très simple :

. on extrais le jeton JWT dans le _header_ `Authorization`. S'il n'est pas définis, on renvoie une erreur `403 - Forbidden` avec une brève explication
. on décode le jeton JWT et on récupère l'utilisateur associé. Si une erreur survient (le jeton ne peut pas être décodé ou l'utilisateur n'existe pas), on renvoie une erreur `403` aussi
. on passe à la suite

Bien entendu, nous n'oublions pas d'ajouter ce _middleware_ à notre conatiner :

[source,ts]
----
// backend/src/core/types.core.ts
export const TYPES = {
  // ...
  FetchLoggedUserMiddleware: Symbol.for("FetchLoggedUserMiddleware"),
};
----

[source,ts]
----
// backend/src/core/container.core.ts
// ...
import { FetchLoggedUserMiddleware } from "../middlewares/fetchLoggedUser.middleware";

export const container = new Container();
// ...
container.bind(TYPES.FetchLoggedUserMiddleware).to(FetchLoggedUserMiddleware);
----

Et maintenant il ne nous reste plus qu'à utiliser le [.underline]#middleware# dans le `UsersController` . Voici par exemple pour la méthode `show` :

[source,diff]
----
// backend/src/controllers/home.controller.ts
// ...
@controller("/users")
export class UsersController {
  // ...
-   @httpGet("/:userId", TYPES.FetchUserMiddleware)
+   @httpGet("/:userId", TYPES.FetchLoggedUserMiddleware)
  public async show(/* ... */) {
+    if (Number(userId) !== req.user.id) {
+      return res.sendStatus(403);
+    }
    return req.user;
  }
  // ...
}
----

Comme vous pouvez le voir, les modifications reste minimes car une partie de la logique est *déportée dans le _middleware_*. Vous pouvez aussi voir que j'ai mis une vérification très simple pour empêcher un utilisateur de consulter les informations d'un autre.

*Le _middleware_ nous a permis de garder une logique très simple dans notre contrôleur.*

Le principe est exactement le même pour la méthode `update` et `destroy`.

[source,diff]
----
// backend/src/controllers/home.controller.ts
// ...
@controller("/users")
export class UsersController {
  // ...

-   @httpGet("/:userId", TYPES.FetchUserMiddleware)
+   @httpGet("/:userId", TYPES.FetchLoggedUserMiddleware)
  public async show(/* ... */)> {
+    if (Number(userId) !== req.user.id) {
+      return res.sendStatus(403);
+    }
    return req.user;
  }

-  @httpPut("/:userId", TYPES.FetchUserMiddleware)
+  @httpPut("/:userId", TYPES.FetchLoggedUserMiddleware)
  public async update(/* ... */)> {
+    if (Number(userId) !== req.user.id) {
+      return res.sendStatus(403);
+    }
    // ...
    return repository.save(req.user);
  }

-  @httpDelete("/:userId", TYPES.FetchUserMiddleware)
+  @httpDelete("/:userId", TYPES.FetchLoggedUserMiddleware)
  public async destroy(/* ... */) {
+    if (Number(userId) !== req.user.id) {
+      return res.sendStatus(403);
+    }
    const repository = await this.databaseService.getRepository(UserRepository);
    await repository.delete(req.user);
  }
}
----

Il est temps d'essayer que notre logique fonctionne. Récupérons un jetons et essayons de voir que tout fonctionne :

[source,bash]
----
$ curl -X POST -d "email=test@test.fr" -d "password=test" http://localhost:3000/tokens
{"token":"eyJhbGciOiJIUzI1NiI..."}
$ curl -H "Authorization: eyJhbGciOiJIUzI1NiI..." http://localhost:3000/users/1
{"id":1,"email":"test@test.fr","hashedPassword":"8574a23599216d7752ef4a2f62..."}
----

Parfait ! et que se passe t'il si nous essayons d'accéder à cette route sans autorisation ?

[source,bash]
----
$ curl http://localhost:3000/users/1
You must provide an `Authorization` header
----

Et voilà. L'accès nous a été interdit comme prévu.

Il est temps de commiter tous nos changement:

[source,bash]
----
$ git add . && git commit -m "Add JWT middleware"
----

== Conclusion

Vous l’avez fait! Vous êtes à mi-chemin! Ce chapitre a été long et difficile, mais c’est un grand pas en avant sur la mise en place d’un mécanisme solide pour gérer l’authentification utilisateur et nous commençons même à gratter la surface pour de simples règles d’autorisation.

Dans le prochain chapitre, nous nous concentrerons sur la personnalisation de la sortie JSON pour l’utilisateur et l’ajout d’un modèle de produit en donnant à l’utilisateur la possibilité de créer un produit et le publier pour la vente.
