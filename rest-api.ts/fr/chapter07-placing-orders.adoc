[#chapter07-placing-orders]
= Création des commandes

Dans les chapitres précédents nous avons traité les associations entre les produits et les utilisateurs. Nous avons aussi vu comment bien les sérialiser en les optimisant afin de pouvoir _scaler_, (c'est-à-dire s'adapter facilement à une forte demande sur notre application). Maintenant, il est temps de commencer à passer des commandes. Cela va être une situation plus complexe parce que nous allons gérer les associations entre les trois modèles. Nous devons être assez malins pour gérer la sortie JSON que nous fournissons.

Dans ce chapitre, nous allons faire plusieurs choses:

* Créer un modèle de commande avec les spécifications correspondantes
* Gérer l’association de sortie JSON entre l’utilisateur de la commande et les modèles de produits
* Envoyer un courriel de confirmation avec le récapitulatif de la commande

Maintenant que tout est clair, nous pouvons commencer à travailler. Vous pouvez cloner le projet jusqu’à ce point avec:

[source,bash]
----
$ git checkout tags/checkpoint_chapter07
----

Créons une nouvelle branche afin de commencer à travailler:

[source,bash]
----
$ git checkout -b chapter07
----

== Modélisation de la commande

Si vous vous souvenez des associations entre les modèles, vous devez vous souvenir que le modèle `Order` est associé aux modèles `User` et `Product`. C’est en fait très simple de gérer cela avec Rails. La partie délicate est lors de la sérialisation de ces objets. J’en parlerai plus en détail plus tard.

Commençons par créer le modèle de la commande. Celui possédera deux relations `ManyToOne`: `User` et `Product`. Il aura aussi une colonne `total` pour le coût total de la commande et ensuite les colonnes classiques `createdAt` et `updatedAt`. Voici l'implémentation complète.

[source,ts]
----
// src/entities/order.entity.ts
import { IsDefined, IsPositive, validateOrReject } from "class-validator";
import {/* ... */} from "typeorm";
import { Product } from "./product.entity";
import { User } from "./user.entity";

@Entity()
export class Order {
  @PrimaryGeneratedColumn()
  id: number;

  @IsDefined()
  @ManyToOne(() => User, (user) => user.orders)
  user: User;

  @IsPositive()
  @Column({ type: "number", unsigned: true })
  total: number;

  @CreateDateColumn()
  createdAt: Date;

  @UpdateDateColumn()
  updatedAt: Date;

  @BeforeInsert()
  @BeforeUpdate()
  async validate() {
    await validateOrReject(this);
  }
}

@EntityRepository(Order)
export class OrderRepository extends Repository<Order> {}
----

Comme vous pouvez le constater, l'implémentation n'apporte rien de nouveau comparé à ce que nous avons déjà vu.

J'en ai profité pour ajouter la contrainte `IsPositive` sur le champ `total` qui est un `number unsigned`. Cela signifie  qu'il ne peut pas être négatif.

Mais avant d'oublier, nous devons aussi définir la relation côté `User`:

[source,ts]
----
// src/entities/user.entity.ts
// ...
import { Order } from "./order.entity";

@Entity()
export class User {
  // ...
  @OneToMany(() => Order, (order) => order.user)
  orders: Order[];
  // ...
}
----

Parfait! Nous sommes prêt à passer à la suite. _Commitons_ tout cela avant:

[source,bash]
----
$ git add . && git commit -m "Generate orders"
----

=== Les commandes et les produits

Nous devons établir la liaison entre la commande et les produits. Cela se fait avec une association _many-to-many_ car de nombreux produits seront placés sur plusieurs commandes et les commandes auront plusieurs produits. Dans ce cas, nous avons donc besoin d’un modèle supplémentaire qui joindra ces deux autres objets et mappera l’association appropriée. Voici l'implémentation:

// -- current

[source,ts]
----
// src/entities/placement.entity.ts
import { IsDefined, validateOrReject } from "class-validator";
import {/* ... */} from "typeorm";
import { Order } from "./order.entity";
import { Product } from "./product.entity";
import { User } from "./user.entity";

@Entity()
export class Placement {
  @PrimaryGeneratedColumn()
  id: number;

  @IsDefined()
  @ManyToOne(() => Product, (product) => product.placements)
  product: Product;

  @IsDefined()
  @ManyToOne(() => Order, (order) => order.placements)
  order: User;

  @BeforeInsert()
  @BeforeUpdate()
  async validate() {
    await validateOrReject(this);
  }
}

@EntityRepository(Placement)
export class PlacementRepository extends Repository<Placement> {}

----

.Ajout de la relation `placements` au modèle `Product`
[source,ts]
----
// src/entities/product.entity.ts
// ...
@Entity()
export class Product {
  // ...
  @OneToMany(() => Placement, (placement) => placement.product)
  placements: Placement[];
  // ...
}
// ...
----

.Ajout de la relation `placements` au modèle `Order`
[source,ts]
----
// src/entities/order.entity.ts
// ...
@Entity()
export class Order {
  // ...
  @OneToMany(() => Placement, (placement) => placement.order)
  placements: Placement[];
  // ...
}
// ...
----

_Commitons_ les changements:

[source,bash]
----
$ git add . && git commit -m "Associates products and orders with a placements model"
----

== Exposer le modèle d’utilisateur

Il est maintenant temps de préparer le contrôleur des commandes à exposer les bonnes commandes. Si vous vous souvenez des chapitres précédents où l’on avait utilisé https://github.com/SeyZ/jsonapi-serializer/[jsonapi-serializer] vous devez vous rappeler que c’était vraiment facile.

Définissons d’abord quelles actions nous allons mettre en place:

. Une action d’indexation pour récupérer les commandes des utilisateurs en cours
. Une action show pour récupérer une commande particulière de l’utilisateur courant
. Une action de création pour passer réellement la commande

Commençons par l’action `index`. Nous devons d’abord créer le contrôleur de commandes. Mais avant de commencer à taper du code, nous devons nous demander:

> Est-ce que je dois laisser les routes de ma commande imbriqués dans le `UsersController` ou bien dois je les isoler?

La réponse est vraiment simple: cela dépend de la quantité d’informations que vous voulez exposer au développeur.

Dans notre cas, nous n'allons pas le faire car nous allons récupérer les commandes de utilisateur sur la route `/orders`. Commençons par quelques tests:

// -- current
.Tests fonctionnels de la méthode `OrdersController.index`
[source,ts]
----
// src/controllers/orders.controller.spec.ts
// ...
describe("OrdersController", () => {
  let userRepository: UserRepository;
  let orderRepository: OrderRepository;
  let jsonWebTokenService: JsonWebTokenService;
  let user: User;
  let stranger: User;
  let jwt: string;
  let strangerJwt: string;
  let order: Order;

  before(async () => {
    jsonWebTokenService = container.get(TYPES.JsonWebTokenService);

    const databaseService = container.get<DatabaseService>(TYPES.DatabaseService);
    userRepository = await databaseService.getRepository(UserRepository);
    orderRepository = await databaseService.getRepository(OrderRepository);

    stranger = await userRepository.save(generateUser());
    strangerJwt = jsonWebTokenService.encode({ userId: stranger.id });
  });

  beforeEach(async () => {
    user = await userRepository.save(generateUser());
    order = await orderRepository.save(generateOrder({ user }));
    jwt = jsonWebTokenService.encode({ userId: user.id });
  });

  describe("index", () => {
    it("should forbid orders without auth", () => agent.get("/orders").expect(403));

    it("should get orders of user", () =>
      agent
        .get("/orders")
        .set("Authorization", jwt)
        .expect(200)
        .then(({ body }) => assert.ok(body.data.some(({ id }) => id === String(order.id)))));
  });
});
----

L'implémentation de ce test devrait vous rappeler celle de `product.controller.spec.ts`. Nous essayons d'accéder au nouvel `endpoint` avec un utilisateur possédant une `Order` et nous vérifions que cette commande apparaît bien dans le retour JSON.

NOTE: Vous avez certainement remarqué la syntaxe `({body}) => ...`. Il s'agit de la fonctionnalité de https://developer.mozilla.org/fr/docs/Web/JavaScript/Reference/Op%C3%A9rateurs/Syntaxe_d%C3%A9composition[la décomposition d'objet]. Elle permet tout simplement de récupérer une propriété contenue dans un object directement dans une variable du même nom. Ainsi `const data = {a: 1}; const a = data.a;` peut être simplifié en `const { a } = {a: 1}`. Cette syntaxe peu perturber donc j'ai préférer l'utiliser qu'à partir de ce chapitre.

Si nous exécutons la suite de tests maintenant, comme vous pouvez vous y attendre, les deux tests échoueront. C’est normal car nous n’avons même pas défini le contrôleur ni même le sérializeur spécifique aux commandes. Alors faisons le.

Alors commençons par le sérialiseur:

[source,ts]
----
// src/utils/serializers.utils.ts
// ...
export const ordersSerializer = new Serializer("orders", {
  attributes: ["total", "createdAt", "updatedAt"],
} as any);
----

Et maintenant nous pouvons l'utiliser dans notre tout nouveau contrôleur:

[source,ts]
----
// src/controllers/orders.controller.ts
import { Request, response, Response } from "express";
import { inject } from "inversify";
import { controller, httpGet } from "inversify-express-utils";
import { TYPES } from "../core/types.core";
import { Order, OrderRepository } from "../entities/order.entity";
import { User } from "../entities/user.entity";
import { DatabaseService } from "../services/database.service";
import { ordersSerializer } from "../utils/serializers.utils";

@controller("/orders", TYPES.FetchLoggedUserMiddleware)
export class OrdersController {
  public constructor(
    @inject(TYPES.DatabaseService)
    private readonly databaseService: DatabaseService
  ) {}

  @httpGet("/")
  public async index({ user }: Request & { user: User }) {
    const repository = await this.databaseService.getRepository(OrderRepository);
    const orders = await repository.find({ user });
    return ordersSerializer.serialize(orders);
  }
}
----

Dans le premier décorateur `@controller`, nous injection globalement le _middleware_ `FetchLoggedUserMiddleware`. Cela signifie qu'il faudra donner une jeton JWT pour accéder à toutes les actions de ce contrôleur. Cela nous permet donc de récupérer l'utilisateur dans la méthode `index` et de l'utiliser directement dans la méthode `find`. Nous utilisons le sérialseur pour formatter les données et les renvoyer.

N'oublions pas de charger notre contôleur puisqu'il s'agit d'un tout nouveau contrôleur:

[source,ts]
----
// src/core/container.core.ts
// ...
import "../controllers/orders.controller";
// ...
----

Et maintenant nos tests devraient passer:

[source,bash]
----
$ npm test
...
  OrderController
    index
      ✓ should forbid orders without auth (44ms)
      ✓ should get orders of user
...
----

Nous aimons nos commits très petits. Alors _commitons_ dès maintenant:

[source,bash]
----
$ git add . && git commit -m "Adds the index action for order"
----


=== Afficher une seule commande

Comme vous pouvez déjà l’imaginer, cette route est très facile. Nous n’avons qu’à mettre en place quelques configurations (routes, action du contrôleur) et un nouveau _middleware_ qui va s'occuper de récupérer la commande et ce sera tout pour cette section. Nous inclurons plus tard les produits liés à cette commande dans le JSON de sortie.

Commençons par ajouter quelques tests:

[source,ts]
----
// src/controllers/orders.controller.spec.ts
// ...
describe("OrdersController", () => {
  // ...
  describe("show", () => {
    it("should forbid show order for other users", () => {
      agent.get(`/orders/${order.id}`).set("Authorization", strangerJwt).expect(403);
    });

    it("should show order", () => {
      agent
        .get(`/orders/${order.id}`)
        .set("Authorization", jwt)
        .expect(200)
        .then(({ body }) => assert.strictEqual(body.data.id, String(order.id)));
    });
  });
  // ...
});
----

Passons à l'implémentation. Nous allons commencer par créer un _middleware_ qui se chargera de chercher la commande en fonction du paramètre. Le code est vraiment très similaire au `FetchProductMiddleware` donc je passerai un peu plus vite la dessus:

.Création du `FetchOrderMiddleware`
[source,ts]
----
// src/middlewares/fetchUser.middleware.ts
// ...
@injectable()
export class FetchOrderMiddleware extends BaseMiddleware {
  constructor(
    @inject(TYPES.DatabaseService)
    private readonly databaseService: DatabaseService
  ) {
    super();
  }

  public async handler(req: Request & { order: Order }, res: Response, next: NextFunction): Promise<void | Response> {
    const orderId = req.query.orderId ?? req.params.orderId;
    const repository = await this.databaseService.getRepository(OrderRepository);
    req.order = await repository.findOne(Number(orderId), {
      relations: ["user"],
    });

    if (!req.order) {
      return res.status(404).send("order not found");
    }
    next();
  }
}
----

.Ajout du `Symbol` pour l'injection dans le container
[source,ts]
----
// src/core/types.core.ts
export const TYPES = {
  // ...
  FetchOrderMiddleware: Symbol.for("FetchOrderMiddleware"),
};

----

.Ajout `FetchOrderMiddleware` dans le container
[source,ts]
----
// src/core/container.core.ts
// ...
export const container = new Container();
// ...
container.bind(TYPES.FetchOrderMiddleware).to(FetchOrderMiddleware);
----

Tous nos tests passent désormais:

[source,bash]
----
$ npm test
  OrderController
    index
      ✓ should forbid orders without auth (44ms)
      ✓ should get orders of user
    show
      ✓ should forbid show order for other users
      ✓ should show orders
----

_Commitons_ les changements et passons à l’action `Product#create`.

[source,bash]
----
$ git commit -am "Adds the show action for order"
----

// -- current

=== Placement et commandes

Il est maintenant temps de donner la possibilité à l’utilisateur de passer quelques commandes. Cela ajoutera de la complexité à l’application, mais ne vous inquiétez pas, nous allons faire les choses une étape à la fois.

Avant de lancer cette fonctionnalité, prenons le temps de réfléchir aux implications de la création d’une commande dans l’application. Je ne parle pas de la mise en place d’un service de transactions comme https://stripe.com/[Stripe] ou https://www.braintreepayments.com/[Braintree] mais de choses comme:

* la gestion des produits en rupture de stock
* la diminution de l’inventaire de produits
* ajouter une certaine validation pour le placement de la commande pour s’assurer qu’il y a suffisamment de produits au moment où la commande est passée

On dirait qu’il reste un paquet de chose à faire mais croyez-moi: vous êtes plus près que vous ne le pensez et ce n’est pas aussi dur que ça en a l’air. Pour l’instant, gardons les choses simples et supposons que nous avons toujours assez de produits pour passer un nombre quelconque de commandes. Nous nous soucions juste de la réponse du serveur pour le moment.

Si vous vous rappelez le modèle de commande, nous avons besoin de trois choses: un total pour la commande, l’utilisateur qui passe la commande et les produits pour la commande. Compte tenu de cette information, nous pouvons commencer à ajouter quelques tests:

[source,ruby]
.test/controllers/api/v1/orders_controller_test.rb
----
# ...
class Api::V1::OrdersControllerTest < ActionDispatch::IntegrationTest
  setup do
    # ...
    @order_params = { order: {
      product_id: [products(:one).id, products(:two).id],
      total: 50
    } }
  end

  # ...

  test 'should forbid create order for unlogged' do
    assert_no_difference('Order.count') do
      post api_v1_orders_url, params: @order_params, as: :json
    end
    assert_response :forbidden
  end

  test 'should create order with two products' do
    assert_difference('Order.count', 1) do
      post api_v1_orders_url,
        params: @order_params,
        headers: { Authorization: JsonWebToken.encode(user_id: @order.user_id) },
        as: :json
    end
    assert_response :created
  end
end
----

Comme vous pouvez le voir, nous sommes en train de créer une variable `order_params` avec les données de la commande. Vous voyez le problème ici? Je l’expliquerai plus tard. Ajoutons simplement le code nécessaire pour faire passer ce test.

Nous devons d’abord ajouter l’action aux routes:

[source,ruby]
.config/routes.rb
----
# ...
Rails.application.routes.draw do
  # ...
  resources :orders, only: %i[index show create]
  # ...
end
----

Ensuite, la mise en œuvre qui est facile:

[source,ruby]
.app/controllers/api/v1/orders_controller.rb
----
class Api::V1::OrdersController < ApplicationController
  before_action :check_login, only: %i[index show create]
  # ...

  def create
    order = current_user.orders.build(order_params)

    if order.save
      render json: order, status: 201
    else
      render json: { errors: order.errors }, status: 422
    end
  end

  private

  def order_params
    params.require(:order).permit(:total, product_ids: [])
  end
end
----

Et maintenant, nos tests devraient tous passer:

[source,bash]
----
$ rake test
.......................................
39 runs, 59 assertions, 0 failures, 0 errors, 0 skips
----

Ok donc tout va bien. Nous devrions maintenant passer au chapitre suivant, non? Laissez-moi faire une pause avant. Nous avons de graves erreurs sur l’application et elles ne sont pas liées au code lui-même mais sur la partie métier.

Ce n’est pas parce que les tests passent que l’application remplit la partie métier de l’application. Je voulais en parler parce que dans de nombreux cas, c’est super facile de simplement recevoir des paramètres et de construire des objets à partir de ces paramètres. Dans notre cas, nous ne pouvons pas nous fier aux données que nous recevons. En effet, nous laissons ici le client fixer le total de la commande! Ouais, c’est fou!

Nous devons donc ajouter quelques validations et calculer le total de la commande dans le modèle. De cette façon, nous ne recevons plus cet attribut total et nous avons un contrôle complet sur cet attribut. Alors faisons-le.

Nous devons d’abord ajouter quelques tests pour le modèle de commande:

[source,ruby]
.test/models/order_test.rb
----
# ...
class OrderTest < ActiveSupport::TestCase

  setup do
    @order = orders(:one)
  end

  test 'Should set total' do
    order = Order.new user_id: @order.user_id
    order.products << products(:one)
    order.products << products(:two)
    order.save

    assert_equal (@product1.price + @product2.price), order.total
  end
end
----

Nous pouvons maintenant ajouter l’implémentation:

[source,ruby]
.app/models/order.rb
----
class Order < ApplicationRecord
  # ...
  def set_total!
    self.total = self.products.map(&:price).sum
  end
end
----

Juste avant que vous ne lanciez vos tests, nous avons besoin de mettre à jour l’usine de commande:


Nous pouvons maintenant _hooker_ la méthode `set_total!` à un rappel `before_validation` pour s’assurer qu’il a le bon total avant la validation.

NOTE: Le _hook_ est une méthode qui se déclenchera automatiquement lors de l'exécution

[source,ruby]
.app/models/order.rb
----
class Order < ApplicationRecord
  before_validation :set_total!
  # ...
end
----

A ce stade, nous nous assurons que le total est toujours présent et supérieur ou égal à zéro, ce qui signifie que nous pouvons supprimer ces validations et supprimer les spécifications. Nos tests devraient passer maintenant:

[source,bash]
----
$ rake test

...........F

Failure:
OrderTest#test_Should_have_a_positive_total [/home/arousseau/github/madeindjs/market_place_api/test/models/order_test.rb:14]:
Expected true to be nil or false


rails test test/models/order_test.rb:11

............................

Finished in 0.542600s, 73.7191 runs/s, 110.5786 assertions/s.
----

Oups! Nous obtenons une _failure_ sur notre précédent test _Should have a positive total_. C'est logique puisque le total de la commande se calcule dynamiquement. Nous pouvons donc tout simplement supprimer ce test qui est devenu obsolète.

Nos tests doivent continuer à passer. _Commitons_ nos changements:

[source,bash]
----
$ git commit -am "Adds the create method for the orders controller"
----

== Envoyer un email de confirmation

La dernière section de ce chapitre sera d’envoyer un courriel de confirmation à l’utilisateur qui vient de créer une commande. Si vous le voulez, vous pouvez sauter cette étape et passer au chapitre suivant! Cette section est plus à un bonus.

Vous êtes peut-être familier avec la manipulation des courriels avec Rails, je vais essayer de rendre cela simple et rapide:

Nous commençons par créer le `order_mailer` avec un mail nommé `send_confirmation`:

[source,bash]
----
$ rails generate mailer order_mailer send_confirmation
----

Maintenant, nous pouvons ajouter quelques tests pour les mails de commandes que nous venons de créer:

[source,ruby]
.test/mailers/order_mailer_test.rb
----
# ...
class OrderMailerTest < ActionMailer::TestCase

  setup do
    @order = orders(:one)
  end

  test "should be set to be delivered to the user from the order passed in" do
    mail = OrderMailer.send_confirmation(@order)
    assert_equal "Order Confirmation", mail.subject
    assert_equal [@order.user.email], mail.to
    assert_equal ['no-reply@marketplace.com'], mail.from
    assert_match "Order: ##{@order.id}", mail.body.encoded
    assert_match "You ordered #{@order.products.count} products", mail.body.encoded
  end

end
----

J’ai simplement copié/collé les tests de la documentation et je les ai adaptés à nos besoins. Nous devons maintenant nous assurer que ces tests passent.

Tout d’abord, nous ajoutons la méthode `OrderMailer#send_confirmation`:

[source,ruby]
.app/mailers/order_mailer.rb
----
class OrderMailer < ApplicationMailer
  default from: 'no-reply@marketplace.com'
  def send_confirmation(order)
    @order = order
    @user = @order.user
    mail to: @user.email, subject: 'Order Confirmation'
  end
end
----

Après avoir ajouté ce code, nous devons maintenant ajouter les vues correspondantes. C’est une bonne pratique d’inclure une version texte en plus de la version HTML.

[source,erb]
----
<%# app/views/order_mailer/send_confirmation.txt.erb %>
Order: #<%= @order.id %>
You ordered <%= @order.products.count %> products:
<% @order.products.each do |product| %>
  <%= product.title %> - <%= number_to_currency product.price %>
<% end %>
----

[source,erb]
----
<!-- app/views/order_mailer/send_confirmation.html.erb -->
<h1>Order: #<%= @order.id %></h1>
<p>You ordered <%= @order.products.count %> products:</p>
<ul>
  <% @order.products.each do |product| %>
    <li><%= product.title %> - <%= number_to_currency product.price %></li>
  <% end %>
</ul>
----

Maintenant, nos tests devraient passer:

[source,bash]
----
$ rake test
........................................
40 runs, 66 assertions, 0 failures, 0 errors, 0 skips
----

Et maintenant, il suffit d’appeler la méthode `OrderMailer#send_confirmation` dans l’action de création sur le contrôleur des ordres:

[source,ruby]
.app/controllers/api/v1/orders_controller.rb
----
class Api::V1::OrdersController < ApplicationController
  # ...
  def create
    order = current_user.orders.build(order_params)

    if order.save
      OrderMailer.send_confirmation(order).deliver
      render json: order, status: 201
    else
      render json: { errors: order.errors }, status: 422
    end
  end
  # ...
end
----

Pour être sûr que nous n’avons rien cassé, lançons tous les tests:

[source,bash]
----
$ rake test
........................................
40 runs, 66 assertions, 0 failures, 0 errors, 0 skips
----

_Commitons_ tout ce que nous venons de faire pour terminer cette section:

[source,bash]
----
$ git add . && git commit -m "Adds order confirmation mailer"
----


Et comme nous arrivons à la fin de notre chapitre, il est temps d'appliquer toutes nos modifications sur la branche master en faisant un _merge_:

[source,bash]
----
$ git checkout master
$ git merge chapter07
----

== Conclusion

Ça y est! Vous avez réussi! Vous pouvez vous applaudir. Je sais que ça a été long mais c’est presque fini, croyez moi.

Sur les chapitres à venir, nous continuerons à travailler sur le modèle de commande pour ajouter des validations lors de la passation d’une commande. Certains scénarios sont:

* Que se passe-t-il lorsque les produits ne sont pas disponibles?
* Diminuer la quantité du produit en cours lors de la passation d’une commande

Le prochain chapitre sera court, mais il est très important pour la santé de l'application. Alors ne le sautez pas.
